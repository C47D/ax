# Writes C structures for various modulations
# Copyright (C) 2016  Richard Meadows <richardeoin>

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from ax_radio import AxRadio
from ax_radio import AxRadioAPRS
from ax_radio import AxRadioGMSK
from _ax_radio import ffi

"""
Convert a CFFI cdata structure to Python dict.

From https://gist.github.com/inactivist/4ef7058c2132fa16759d
"""
def __convert_struct_field( s, fields ):
    for field,fieldtype in fields:
        if fieldtype.type.kind == 'primitive':
            yield (field,getattr( s, field ))
        else:
            yield (field, convert_to_python( getattr( s, field ) ))

def convert_to_python(s):
    type=ffi.typeof(s)
    if type.kind == 'struct':
        return dict(__convert_struct_field( s, type.fields ) )
    elif type.kind == 'union':
        return dict(__convert_struct_field( s, type.fields ) )
    elif type.kind == 'array':
        if type.item.kind == 'primitive':
            if type.item.cname == 'char':
                return ffi.string(s)
            else:
                return [ s[i] for i in range(type.length) ]
        else:
            return [ convert_to_python(s[i]) for i in range(type.length) ]
    elif type.kind == 'primitive':
        return int(s)

"""
Print as c structure
"""
def print_c_struct_item(obj, indent=0):
    if type(obj) is int:
        return "{}".format(obj)
    elif type(obj) is float:
        return "{:.7f}".format(obj)
    elif type(obj) is dict:
        fstr = "{{\n{}\n" + " "*indent + "}}"
        return fstr.format(print_c_struct(obj, indent+2))
    elif type(obj) is list:
        fstr = ",\n" + " "*indent
        string = fstr.join([print_c_struct_item(o, indent) for o in obj])
        return "{{{}}}".format(string)
    else:
        print(type(obj))

def print_c_struct(s, indent=0):
    fstr = " "*indent + ".{} = {}"
    items = [fstr.format(name, print_c_struct_item(s[name], indent)) for name in s]
    return ',\n'.join(sorted(items))

"""
Returns string for a given modulation
"""
def write_ax_modulation_struct(f_c, f_h, name, radio):
    mod = radio.get_modulation()
    mod_dict = convert_to_python(mod[0])

    # need to choose options for union
    if mod_dict['modulation'] is 10: # afsk
        mod_dict['parameters'] = {
            'afsk': mod_dict['parameters']['afsk']
        }
    else:
        mod_dict['parameters'] = {
            'fsk': mod_dict['parameters']['fsk']
        }

    f_c.write("ax_modulation {} = ".format(name) +
              print_c_struct_item(mod_dict) + ";\n\n");

    f_h.write("ax_modulation {};\n\n".format(name));

"""
main
"""
if __name__ == "__main__":

    out_path=''

    with open(    out_path+'ax/ax_modulations_autogen.c', 'w') as f_c:
        with open(out_path+'ax/ax_modulations_autogen.h', 'w') as f_h:

            block_header = ("/**\n"
                            " * Autogenerated modulation structures\n"
                            " */\n"
                            "\n")

            f_c.write(block_header)
            f_h.write(block_header)
            f_h.write("#ifndef AX_MODULATIONS_AUTOGEN_H\n"
                      "#define AX_MODULATIONS_AUTOGEN_H\n"
                      "\n")

            f_c.write("#include \"ax/ax.h\"\n\n")
            f_h.write("#include \"ax/ax.h\"\n\n")

            # Default
            radio = AxRadio()
            write_ax_modulation_struct(f_c, f_h, "ax_mod_default", radio)

            # AX25 (APRS)
            radio = AxRadioAPRS(power=1)
            write_ax_modulation_struct(f_c, f_h, "ax_mod_ax25", radio)

            f_h.write("#endif /* AX_MODULATIONS_AUTOGEN_H */")
